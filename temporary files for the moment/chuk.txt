[
  {
    "path": "src/types/blog.ts",
    "content": "// src/types/blog.ts\nimport { FAQItem, TutorialStep, VideoMetadata } from '@/lib/generateSchemas';\n\nexport interface BlogMetadata {\n  slug: string;\n  title: string;\n  excerpt: string;\n  tags: string[];\n  image?: string;\n  imageAlt?: string;\n  imageWidth?: number;       // \ud83c\udd95 PHASE 3\n  imageHeight?: number;      // \ud83c\udd95 PHASE 3\n  imageCaption?: string;     // \ud83c\udd95 PHASE 3\n  dateModified?: string;\n  tldr?: TLDR;\n  faqItems?: FAQItem[];\n  url: string;\n  topicalMap?: any;           // Replace 'any' with proper type if you have one\n  keywordStrategy?: any;      // Replace 'any' with proper type if you have one\n  contentRelations?: any;     // Replace 'any' with proper type if you have one\n  seoMetrics?: any;  \n  \n  // Optional fields for backward compatibility\n  date: string;\n  author: string;\n  readTime: number | string;\n  category?: string;\n  galleryImages?: GalleryImage[];\n  canonical?: string;\n  updatedDate?: string;\n  wordCount?: number;\n  eventData?: {              // \ud83c\udd95 ADD THIS\n    name: string;\n    startDate: string;\n    endDate: string;\n    eventStatus: string;\n    eventAttendanceMode: string;\n    isVirtual: boolean;\n  };\n}\n\nexport interface KeywordStrategy {\n  avoidKeywords: string[];\n  clusteredWith: string[];\n  serpVerified: boolean;\n  serpOverlapScore: number;\n  lastCannibalCheck: string;\n}\n\nexport interface ContentRelations {\n  linksToPostsCount: number;\n  relatedPostSlugs: string[];\n  competingPosts: string[];\n}\n\nexport interface SeoMetrics {\n  targetRankPosition: number;\n  estimatedMonthlySearches: number;\n  difficulty: number;\n  lastRankCheck: string;\n}\n\n// \u2705 Define TutorialMetadata locally (not imported)\nexport interface TutorialMetadata {\n  name: string;\n  description: string;\n  totalTime: string;          // \u2705 Required field (no ?)\n  estimatedCost: {\n    currency: string;\n    value: string;\n  };\n  tools: string[];\n  supplies: string[];\n}\n\nexport interface TopicalMap {\n  position: string;\n  parentPillar: string;\n  relatedClusters: string[];\n  primaryKeyword: string;\n  searchIntent: string;\n  topicalBoundary: string;\n  hierarchyLevel: number;\n}\n\n// Add this interface after imports, BEFORE BlogPost\nexport interface TLDR {\n  summary: string[];\n  faqs?: FAQ[];           // Optional\n  creativeLine?: string;  // Optional  \n  keyTakeaways: string[];\n}\n\n// Also add FAQ interface\nexport interface FAQ {\n  question: string;\n  answer: string;\n}\n\n// Rest of your types...\nexport interface Category {\n  name: string;\n  slug: string;\n  description: string;\n  count: number;\n}\n\nexport interface Tag {\n  name: string;\n  slug: string;\n  count: number;\n}\n\nexport interface GalleryImage {\n  url: string;\n  alt: string;\n  width?: number;\n  height?: number;\n  caption?: string;\n}\n\n\nexport interface BlogPost {\n  slug: string;\n  title: string;\n  excerpt: string;\n  content: string;\n  date: string;\n  author: string;\n  tags: string[];\n  image?: string;\n  imageAlt?: string;\n  imageWidth?: number;\n  imageHeight?: number;\n  imageCaption?: string;\n  readTime: number | string;\n  canonical: string;\n  updatedDate?: string;\n  category?: string;\n  dateModified?: string;\n  wordCount?: number;\n  faqItems?: FAQItem[];\n  tutorialSteps?: TutorialStep[];\n  tutorialMetadata?: TutorialMetadata;\n  videoMetadata?: VideoMetadata;\n  galleryImages?: GalleryImage[];\n  tldr?: TLDR;\n  eventData?: {\n    name: string;\n    startDate: string;\n    endDate: string;\n    eventStatus: string;\n    eventAttendanceMode: string;\n    isVirtual: boolean;\n  };\n  topicalMap?: TopicalMap;\n  keywordStrategy?: KeywordStrategy;\n  contentRelations?: ContentRelations;\n  seoMetrics?: SeoMetrics;\n}\n"
  },
  {
    "path": "src/lib/blog.ts",
    "content": "import fs from 'fs';\nimport path from 'path';\nimport matter from 'gray-matter';\nimport { BlogPost, BlogMetadata, TopicalMap, KeywordStrategy, ContentRelations, SeoMetrics, TutorialMetadata } from '@/types/blog';\nimport { marked } from 'marked';\nimport { EventData } from './generateSchemas';\n\nmarked.setOptions({\n  breaks: true,\n  gfm: true,\n});\n\nconst BLOG_DIRECTORY = path.join(process.cwd(), 'src/content/blogs');\nconst METADATA_DIRECTORY = path.join(process.cwd(), 'src/content/metadata');\n\ninterface CacheEntry<T> {\n  data: T;\n  timestamp: number;\n}\n\nclass MetadataCache {\n  private cache = new Map<string, CacheEntry<any>>();\n  private readonly TTL = 3600000;\n\n  get<T>(key: string): T | null {\n    const entry = this.cache.get(key);\n    if (!entry) return null;\n    if (Date.now() - entry.timestamp > this.TTL) {\n      this.cache.delete(key);\n      return null;\n    }\n    return entry.data as T;\n  }\n\n  set<T>(key: string, data: T): void {\n    this.cache.set(key, {\n      data,\n      timestamp: Date.now(),\n    });\n  }\n\n  clear(): void {\n    this.cache.clear();\n  }\n\n  getStats() {\n    return {\n      size: this.cache.size,\n      keys: Array.from(this.cache.keys()),\n    };\n  }\n}\n\nconst metadataCache = new MetadataCache();\n\ninterface ImageMetadata {\n  url: string;\n  width: number;\n  height: number;\n  alt: string;\n  caption?: string;\n}\n\nfunction loadMetadataFile<T>(filename: string): T {\n  const cacheKey = `metadata:${filename}`;\n  \n  const cached = metadataCache.get<T>(cacheKey);\n  if (cached) {\n    return cached;\n  }\n\n  try {\n    const filePath = path.join(METADATA_DIRECTORY, filename);\n    const content = fs.readFileSync(filePath, 'utf8');\n    const data = JSON.parse(content) as T;\n    \n    metadataCache.set(cacheKey, data);\n    \n    return data;\n  } catch (error) {\n    console.error(`Error loading metadata file ${filename}:`, error);\n    return {} as T;\n  }\n}\n\n\nfunction ensureArray(value: any): string[] {\n  if (Array.isArray(value)) return value;\n  if (typeof value === 'string') return value.split(',').map(s => s.trim());\n  return [];\n}\n\n\nfunction getMetadataFromJSON(slug: string): Partial<BlogMetadata> {\n  try {\n    const titles = loadMetadataFile<Record<string, string>>('titles.json');\n    const excerpts = loadMetadataFile<Record<string, string>>('excerpts.json');\n    const tags = loadMetadataFile<Record<string, string[]>>('tags.json');\n\n    // merged alt+caption into images.json\n    const images = loadMetadataFile<Record<string, ImageMetadata>>('images.json');\n\n    const dateModified = loadMetadataFile<Record<string, string>>('dateModified.json');\n    const tldrs = loadMetadataFile<\n      Record<\n        string,\n        {\n          summary: string[];\n          keyTakeaways: string[];\n          faqs?: any[];\n          creativeLine?: string;\n        }\n      >\n    >('tldr.json');\n\n    const faqs = loadMetadataFile<Record<string, any[]>>('faqItems.json');\n    const events = loadMetadataFile<Record<string, EventData>>('events.json');\n\n    const topicalMaps = loadMetadataFile<Record<string, any>>('topicalMaps.json');\n    const keywordStrategies = loadMetadataFile<Record<string, any>>('keywordStrategies.json');\n    const contentRelations = loadMetadataFile<Record<string, any>>('contentRelations.json');\n    const seoMetrics = loadMetadataFile<Record<string, any>>('seoMetrics.json');\n\n    const imageData = images[slug];\n\n    let imageUrl: string | undefined;\n    let imageWidth: number | undefined;\n    let imageHeight: number | undefined;\n    let imageAlt: string | undefined;\n    let imageCaption: string | undefined;\n\n    if (typeof imageData === 'string') {\n      imageUrl = imageData;\n      // derive alt defaults if plain string (no object)\n      imageAlt = undefined;\n      imageWidth = 1200;\n      imageHeight = 630;\n    } else if (imageData && typeof imageData === 'object') {\n      imageUrl = imageData.url;\n      imageWidth = imageData.width;\n      imageHeight = imageData.height;\n      imageAlt = imageData.alt;\n      imageCaption = imageData.caption;\n    }\n\n    return {\n      title: titles[slug] || undefined,\n      excerpt: excerpts[slug] || undefined,\n      tags: tags[slug] || undefined,\n      image: imageUrl,\n      imageAlt: imageAlt,\n      imageWidth: imageWidth,\n      imageHeight: imageHeight,\n      imageCaption: imageCaption,\n      dateModified: dateModified[slug] || undefined,\n      tldr: tldrs[slug] || undefined,\n      faqItems: faqs[slug] || undefined,\n      eventData: events[slug] || undefined,\n      topicalMap: topicalMaps[slug] || undefined,\n      keywordStrategy: keywordStrategies[slug] || undefined,\n      contentRelations: contentRelations[slug] || undefined,\n      seoMetrics: seoMetrics[slug] || undefined,\n    };\n  } catch (error) {\n    console.error(`Error getting metadata for ${slug}:`, error);\n    return {};\n  }\n}\n\nfunction getMetadataFromFrontmatter(slug: string): Partial<BlogMetadata> {\n  try {\n    const filePath = path.join(BLOG_DIRECTORY, `${slug}.md`);\n    const content = fs.readFileSync(filePath, 'utf8');\n    const { data } = matter(content);\n    \n    return {\n      date: data.date,\n      author: data.author,\n      readTime: data.readTime,\n      category: data.category,\n      canonical: data.canonical || `https://mirelleinspo.com/blog/${slug}`,\n      wordCount: data.wordCount,\n      tags: data.tags, // \u2705 ADD THIS\n    };\n  } catch (error) {\n    console.error(`Error reading frontmatter for ${slug}:`, error);\n    return {};\n  }\n}\n\nexport async function getAllBlogPosts(): Promise<BlogMetadata[]> {\n  const cacheKey = 'all-blog-posts';\n  \n  const cached = metadataCache.get<BlogMetadata[]>(cacheKey);\n  if (cached) {\n    return cached;\n  }\n\n  try {\n    const files = fs.readdirSync(BLOG_DIRECTORY);\n    const posts = files\n      .filter(file => file.endsWith('.md'))\n      .map(file => {\n        const slug = file.replace('.md', '');\n        \n        const jsonMetadata = getMetadataFromJSON(slug);\n        const frontmatterMetadata = getMetadataFromFrontmatter(slug);\n        \n        return {\n          slug,\n          title: jsonMetadata.title || 'Untitled',\n          excerpt: jsonMetadata.excerpt || '',\n          date: frontmatterMetadata.date || new Date().toISOString(),\n          author: frontmatterMetadata.author || 'Anonymous',\n          tags: ensureArray(jsonMetadata.tags || frontmatterMetadata.tags),\n          image: jsonMetadata.image || null,\n          imageAlt: jsonMetadata.imageAlt,\n          imageWidth: jsonMetadata.imageWidth,\n          imageHeight: jsonMetadata.imageHeight,\n          imageCaption: jsonMetadata.imageCaption,\n          readTime: frontmatterMetadata.readTime || '5 min',\n          category: frontmatterMetadata.category,\n          canonical: frontmatterMetadata.canonical || `https://mirelleinspo.com/blog/${slug}`,\n          dateModified: jsonMetadata.dateModified,\n          wordCount: frontmatterMetadata.wordCount,\n          tldr: jsonMetadata.tldr,\n          eventData: jsonMetadata.eventData,\n          faqItems: jsonMetadata.faqItems,\n          topicalMap: jsonMetadata.topicalMap,\n          keywordStrategy: jsonMetadata.keywordStrategy,\n          contentRelations: jsonMetadata.contentRelations,\n          seoMetrics: jsonMetadata.seoMetrics,\n        } as BlogMetadata;\n      })\n      .sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());\n    \n    metadataCache.set(cacheKey, posts);\n    \n    return posts;\n  } catch (error) {\n    console.error('Error reading blog posts:', error);\n    return [];\n  }\n}\n\nexport async function getBlogPost(slug: string): Promise<BlogPost | null> {\n  const cacheKey = `blog-post:${slug}`;\n  \n  const cached = metadataCache.get<BlogPost>(cacheKey);\n  if (cached) {\n    return cached;\n  }\n\n  try {\n    const filePath = path.join(BLOG_DIRECTORY, `${slug}.md`);\n    const fileContent = fs.readFileSync(filePath, 'utf8');\n    const { data, content: markdownContent } = matter(fileContent);\n    \n    let htmlContent = await marked(markdownContent);\n    \n    htmlContent = htmlContent.replace(\n      /<h2>(.*?)<\\/h2>/g,\n      (match, text) => {\n        const cleanText = text.replace(/<[^>]*>/g, '');\n        const id = cleanText\n          .toLowerCase()\n          .replace(/[^a-z0-9]+/g, '-')\n          .replace(/^-+|-+$/g, '');\n        return `<h2 id=\"${id}\">${text}</h2>`;\n      }\n    );\n    \n    const jsonMetadata = getMetadataFromJSON(slug);\n    \n    const post: BlogPost = {\n      slug,\n      title: jsonMetadata.title || data.title || 'Untitled',\n      excerpt: jsonMetadata.excerpt || data.excerpt || '',\n      content: htmlContent,\n      date: data.date || new Date().toISOString(),\n      author: data.author || 'Anonymous',\n      tags: ensureArray(jsonMetadata.tags || data.tags),\n      image: jsonMetadata.image || data.image || null,\n      imageAlt: jsonMetadata.imageAlt || data.imageAlt,\n      imageWidth: jsonMetadata.imageWidth || data.imageWidth || 1200,\n      imageHeight: jsonMetadata.imageHeight || data.imageHeight || 630,\n      imageCaption: jsonMetadata.imageCaption || data.imageCaption,\n      readTime: data.readTime || '5 min',\n      category: data.category,\n      canonical: data.canonical || `https://mirelleinspo.com/blog/${slug}`,\n      dateModified: jsonMetadata.dateModified || data.dateModified,\n      wordCount: data.wordCount,\n      tldr: jsonMetadata.tldr || data.tldr,\n      eventData: jsonMetadata.eventData || data.eventData,\n      faqItems: jsonMetadata.faqItems || data.faqItems,\n      topicalMap: jsonMetadata.topicalMap || data.topicalMap,\n      keywordStrategy: jsonMetadata.keywordStrategy || data.keywordStrategy,\n      contentRelations: jsonMetadata.contentRelations || data.contentRelations,\n      seoMetrics: jsonMetadata.seoMetrics || data.seoMetrics,\n    };\n    \n    metadataCache.set(cacheKey, post);\n    \n    return post;\n  } catch (error) {\n    console.error(`Error reading blog post ${slug}:`, error);\n    return null;\n  }\n}\n\nexport async function getAllBlogSlugs(): Promise<string[]> {\n  try {\n    const files = fs.readdirSync(BLOG_DIRECTORY);\n    return files\n      .filter(file => file.endsWith('.md'))\n      .map(file => file.replace('.md', ''));\n  } catch (error) {\n    console.error('Error reading blog slugs:', error);\n    return [];\n  }\n}\n\nexport async function getPostsByCategory(category: string): Promise<BlogMetadata[]> {\n  const cacheKey = `category:${category}`;\n  \n  const cached = metadataCache.get<BlogMetadata[]>(cacheKey);\n  if (cached) return cached;\n\n  const allPosts = await getAllBlogPosts();\n  const filtered = allPosts.filter(post => post.category === category);\n  \n  metadataCache.set(cacheKey, filtered);\n  return filtered;\n}\n\nexport async function getPostsByTag(tag: string): Promise<BlogMetadata[]> {\n  const cacheKey = `tag:${tag}`;\n  \n  const cached = metadataCache.get<BlogMetadata[]>(cacheKey);\n  if (cached) return cached;\n\n  const allPosts = await getAllBlogPosts();\n  const filtered = allPosts.filter(post => \n    post.tags?.some(t => t.toLowerCase() === tag.toLowerCase())\n  );\n  \n  metadataCache.set(cacheKey, filtered);\n  return filtered;\n}\n\nexport async function getAllCategories() {\n  const allPosts = await getAllBlogPosts();\n  const categoryMap = new Map<string, number>();\n  \n  allPosts.forEach(post => {\n    if (post.category) {\n      categoryMap.set(post.category, (categoryMap.get(post.category) || 0) + 1);\n    }\n  });\n  \n  return Array.from(categoryMap.entries()).map(([name, count]) => ({\n    name,\n    slug: name.toLowerCase().trim().replace(/[^\\w\\s-]/g, '').replace(/[\\s_-]+/g, '-').replace(/^-+|-+$/g, ''),\n    count,\n  }));\n}\n\nexport async function getAllTags() {\n  const allPosts = await getAllBlogPosts();\n  const tagMap = new Map<string, number>();\n  \n  allPosts.forEach(post => {\n    post.tags?.forEach(tag => {\n      tagMap.set(tag, (tagMap.get(tag) || 0) + 1);\n    });\n  });\n  \n  return Array.from(tagMap.entries())\n    .map(([slug, count]) => ({\n      name: slug.split('-').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' '),\n      slug: slug,\n      count,\n    }))\n    .sort((a, b) => b.count - a.count);\n}\n\nexport async function getRelatedPosts(currentSlug: string, limit: number = 3): Promise<BlogMetadata[]> {\n  const currentPost = await getBlogPost(currentSlug);\n  if (!currentPost) return [];\n  \n  const allPosts = await getAllBlogPosts();\n  \n  // \ud83c\udd95 TOPICAL MAPPING: Prioritize related clusters first\n  if (currentPost.contentRelations?.relatedPostSlugs) {\n    const relatedSlugs = currentPost.contentRelations.relatedPostSlugs;\n    const relatedPosts = allPosts\n      .filter(post => relatedSlugs.includes(`/blog/${post.slug}`) || relatedSlugs.includes(post.slug))\n      .slice(0, limit);\n    \n    if (relatedPosts.length >= limit) {\n      return relatedPosts;\n    }\n  }\n  \n  const scoredPosts = allPosts\n    .filter(post => post.slug !== currentSlug)\n    .map(post => {\n      let score = 0;\n      \n      if (post.category === currentPost.category) score += 3;\n      \n      const sharedTags = post.tags?.filter(tag => \n        currentPost.tags?.includes(tag)\n      ).length || 0;\n      score += sharedTags;\n      \n      return { post, score };\n    })\n    .filter(item => item.score > 0)\n    .sort((a, b) => b.score - a.score)\n    .slice(0, limit)\n    .map(item => item.post);\n  \n  return scoredPosts;\n}\n\nexport async function getPaginatedPosts(page: number = 1, perPage: number = 12): Promise<{\n  posts: BlogMetadata[];\n  totalPages: number;\n  currentPage: number;\n  totalPosts: number;\n}> {\n  const allPosts = await getAllBlogPosts();\n  const totalPosts = allPosts.length;\n  const totalPages = Math.ceil(totalPosts / perPage);\n  const startIndex = (page - 1) * perPage;\n  const endIndex = startIndex + perPage;\n  const posts = allPosts.slice(startIndex, endIndex);\n  \n  return {\n    posts,\n    totalPages,\n    currentPage: page,\n    totalPosts,\n  };\n}\n\n// \ud83c\udd95 TOPICAL MAPPING UTILITY FUNCTIONS\nexport async function getClusterPosts(pillarSlug: string): Promise<BlogMetadata[]> {\n  const allPosts = await getAllBlogPosts();\n  return allPosts.filter(post => \n    post.topicalMap?.position === 'cluster' && \n    (post.topicalMap.parentPillar === pillarSlug || post.topicalMap.parentPillar === `/blog/${pillarSlug}`)\n  );\n}\n\nexport async function getPillarPosts(): Promise<BlogMetadata[]> {\n  const allPosts = await getAllBlogPosts();\n  return allPosts.filter(post => post.topicalMap?.position === 'pillar');\n}\n\nexport async function detectCannibalization(slug: string): Promise<{\n  hasRisk: boolean;\n  competingPosts: BlogMetadata[];\n  recommendations: string[];\n}> {\n  const currentPost = await getBlogPost(slug);\n  if (!currentPost) return { hasRisk: false, competingPosts: [], recommendations: [] };\n  \n  const allPosts = await getAllBlogPosts();\n  const competingPosts: BlogMetadata[] = [];\n  const recommendations: string[] = [];\n  \n  const primaryKeyword = currentPost.topicalMap?.primaryKeyword;\n  \n  if (primaryKeyword) {\n    allPosts.forEach(post => {\n      if (post.slug === slug) return;\n      \n      if (post.topicalMap?.primaryKeyword === primaryKeyword) {\n        competingPosts.push(post);\n        recommendations.push(`Post \"${post.title}\" targets same primary keyword: \"${primaryKeyword}\"`);\n      }\n      \n      if (currentPost.keywordStrategy?.avoidKeywords?.includes(post.topicalMap?.primaryKeyword || '')) {\n        recommendations.push(`Warning: You're targeting \"${post.topicalMap?.primaryKeyword}\" which should be avoided`);\n      }\n    });\n  }\n  \n  return {\n    hasRisk: competingPosts.length > 0 || recommendations.length > 0,\n    competingPosts,\n    recommendations,\n  };\n}\n\nexport function clearBlogCache() {\n  metadataCache.clear();\n}\n\nexport function getCacheStats() {\n  return metadataCache.getStats();\n}\n"
  },
  {
    "path": "src/components/Blog/Pagination.tsx",
    "content": "interface PaginationProps {\n  currentPage: number;\n  totalPages: number;\n  baseUrl: string;\n}\n\nexport default function Pagination({ currentPage, totalPages, baseUrl }: PaginationProps) {\n  if (totalPages <= 1) {\n    return null;\n  }\n\n  // \u2705 NEW - Generate page numbers with ellipsis for large page counts\n  const getPageNumbers = () => {\n    const pages: (number | string)[] = [];\n    const showEllipsisThreshold = 7;\n\n    if (totalPages <= showEllipsisThreshold) {\n      // Show all pages if total is small\n      for (let i = 1; i <= totalPages; i++) {\n        pages.push(i);\n      }\n    } else {\n      // Show first page\n      pages.push(1);\n\n      // Show ellipsis or pages around current page\n      if (currentPage > 3) {\n        pages.push('...');\n      }\n\n      // Show pages around current page\n      for (let i = Math.max(2, currentPage - 1); i <= Math.min(totalPages - 1, currentPage + 1); i++) {\n        pages.push(i);\n      }\n\n      // Show ellipsis before last page\n      if (currentPage < totalPages - 2) {\n        pages.push('...');\n      }\n\n      // Show last page\n      pages.push(totalPages);\n    }\n\n    return pages;\n  };\n\n  const pageNumbers = getPageNumbers();\n  const prevPage = currentPage > 1 ? currentPage - 1 : null;\n  const nextPage = currentPage < totalPages ? currentPage + 1 : null;\n\n  return (\n    <nav className=\"flex justify-center items-center gap-2 mt-12\" aria-label=\"Pagination\">\n      {/* Previous Button */}\n      {prevPage ? (\n        <a\n          href={`${baseUrl}?page=${prevPage}`}\n          className=\"px-4 py-2 bg-pink-600 text-white rounded-lg hover:bg-pink-700 transition-colors font-medium\"\n          aria-label=\"Previous page\"\n        >\n          \u2190 Previous\n        </a>\n      ) : (\n        <button\n          disabled\n          className=\"px-4 py-2 bg-gray-200 text-gray-400 rounded-lg cursor-not-allowed font-medium\"\n          aria-label=\"Previous page (disabled)\"\n        >\n          \u2190 Previous\n        </button>\n      )}\n\n      {/* Page Numbers */}\n      <div className=\"flex gap-2\">\n        {pageNumbers.map((page, index) => {\n          if (page === '...') {\n            return (\n              <span key={`ellipsis-${index}`} className=\"px-4 py-2 text-gray-500\">\n                ...\n              </span>\n            );\n          }\n\n          const pageNum = page as number;\n          const isActive = pageNum === currentPage;\n\n          return (\n            <a\n              key={pageNum}\n              href={`${baseUrl}?page=${pageNum}`}\n              className={`px-4 py-2 rounded-lg transition-colors font-medium ${\n                isActive\n                  ? 'bg-pink-600 text-white'\n                  : 'bg-gray-100 text-gray-700 hover:bg-gray-200'\n              }`}\n              aria-label={`Page ${pageNum}`}\n              aria-current={isActive ? 'page' : undefined}\n            >\n              {pageNum}\n            </a>\n          );\n        })}\n      </div>\n\n      {/* Next Button */}\n      {nextPage ? (\n        <a\n          href={`${baseUrl}?page=${nextPage}`}\n          className=\"px-4 py-2 bg-pink-600 text-white rounded-lg hover:bg-pink-700 transition-colors font-medium\"\n          aria-label=\"Next page\"\n        >\n          Next \u2192\n        </a>\n      ) : (\n        <button\n          disabled\n          className=\"px-4 py-2 bg-gray-200 text-gray-400 rounded-lg cursor-not-allowed font-medium\"\n          aria-label=\"Next page (disabled)\"\n        >\n          Next \u2192\n        </button>\n      )}\n    </nav>\n  );\n}\n"
  }
]
