[
  {
    "path": "src/app/blog/[slug]/page.tsx",
    "content": "import { notFound } from 'next/navigation';\nimport { getBlogPost, getAllBlogSlugs } from '@/lib/blog';\nimport BlogPost from '@/components/Blog/BlogPost';\nimport Breadcrumbs from '@/components/Breadcrumbs';\nimport RelatedPosts from '@/components/Blog/RelatedPosts'; // \u2705 NEW - Import RelatedPosts component\nimport type { Metadata } from 'next';\nimport { generateSchemas } from '@/lib/generateSchemas';\n\ninterface PageProps {\n  params: {\n    slug: string;\n  };\n}\n\nexport async function generateStaticParams() {\n  const slugs = await getAllBlogSlugs();\n  return slugs.map((slug) => ({\n    slug: slug,\n  }));\n}\n\nexport async function generateMetadata({ params }: PageProps): Promise<Metadata> {\n  const { slug } = params;\n  const post = await getBlogPost(slug);\n  \n  if (!post) {\n    return {\n      title: 'Post Not Found - Mirelle',\n      description: 'The blog post you are looking for does not exist.',\n      robots: {\n        index: false,\n        follow: false,\n      },\n    };\n  }\n\n  const canonicalUrl = `https://mirelleinspo.com/blog/${slug}`;\n  const imageUrl = post.image ? `https://mirelleinspo.com${post.image}` : 'https://mirelleinspo.com/og-default.png';\n  const imageAltText = post.imageAlt || post.title;\n  \n  return {\n    title: `${post.title} | Mirelle`,\n    description: post.excerpt || `Discover ${post.title} - expert nail tips, trends, and tutorials from Mirelle.`,\n    keywords: post.tags?.join(', ') || 'nail art, nail care, nail trends, manicure tips, nail design',\n    authors: [{ name: post.author || 'Mirelle' }],\n    creator: post.author || 'Mirelle',\n    publisher: 'Mirelle',\n    alternates: {\n      canonical: canonicalUrl,\n    },\n    robots: {\n      index: true,\n      follow: true,\n      googleBot: {\n        index: true,\n        follow: true,\n        'max-video-preview': -1,\n        'max-image-preview': 'large',\n        'max-snippet': -1,\n      },\n    },\n    openGraph: {\n      title: `${post.title} | Mirelle`,\n      description: post.excerpt || `Discover ${post.title} - expert nail inspiration from Mirelle.`,\n      type: 'article',\n      url: canonicalUrl,\n      siteName: 'Mirelle',\n      locale: 'en_US',\n      images: [{\n        url: imageUrl,\n        width: post.imageWidth || 1200,\n        height: post.imageHeight || 630,\n        alt: post.title,\n        type: 'image/jpeg',\n      }],\n      publishedTime: post.date,\n      modifiedTime: post.updatedDate || post.date,\n      authors: [post.author || 'Mirelle'],\n      section: post.category || 'Nail Care',\n      tags: post.tags || [],\n    },\n    twitter: {\n      card: 'summary_large_image',\n      title: `${post.title} | Mirelle`,\n      description: post.excerpt || `Discover ${post.title} - expert nail inspiration from Mirelle.`,\n      images: [imageUrl],\n      creator: '@mirelleinspo',\n      site: '@mirelleinspo',\n    },\n    other: {\n      'article:published_time': post.date,\n      'article:modified_time': post.dateModified || post.updatedDate || post.date,\n      'article:author': post.author || 'Mirelle',\n      'article:section': post.category || 'Nail Care',\n      'article:tag': post.tags?.join(', ') || '',\n    },\n  };\n}\n\nexport default async function BlogPostPage({ params }: PageProps) {\n  const { slug } = params;\n  const post = await getBlogPost(slug);\n  \n  if (!post) notFound();\n\n  // \u2705 UPDATED: Pass galleryImages to schema generator\n  const schemas = generateSchemas({\n    post,\n    slug: params.slug,\n    faqItems: post.faqItems,\n    tutorialSteps: post.tutorialSteps,\n    tutorialMetadata: post.tutorialMetadata,\n    galleryImages: post.galleryImages,  // \u2705 NEW: Pass gallery images\n  });\n  \n\n  return (\n    <>\n      {/* Core Structured Data */}\n      <script \n        type=\"application/ld+json\" \n        dangerouslySetInnerHTML={{ __html: JSON.stringify(schemas.articleSchema) }} \n      />\n      <script \n        type=\"application/ld+json\" \n        dangerouslySetInnerHTML={{ __html: JSON.stringify(schemas.breadcrumbSchema) }} \n      />\n      <script \n        type=\"application/ld+json\" \n        dangerouslySetInnerHTML={{ __html: JSON.stringify(schemas.websiteSchema) }} \n      />\n      <script \n        type=\"application/ld+json\" \n        dangerouslySetInnerHTML={{ __html: JSON.stringify(schemas.organizationSchema) }} \n      />\n      \n      {/* Conditional Structured Data */}\n      {schemas.faqSchema && (\n        <script \n          type=\"application/ld+json\" \n          dangerouslySetInnerHTML={{ __html: JSON.stringify(schemas.faqSchema) }} \n        />\n      )}\n      {schemas.howToSchema && (\n        <script \n          type=\"application/ld+json\" \n          dangerouslySetInnerHTML={{ __html: JSON.stringify(schemas.howToSchema) }} \n        />\n      )}\n      {schemas.videoSchema && (\n        <script \n          type=\"application/ld+json\" \n          dangerouslySetInnerHTML={{ __html: JSON.stringify(schemas.videoSchema) }} \n        />\n      )}\n      {/* \u2705 NEW: Add image gallery schema */}\n      {schemas.imageGallerySchema && (\n        <script \n          type=\"application/ld+json\" \n          dangerouslySetInnerHTML={{ __html: JSON.stringify(schemas.imageGallerySchema) }} \n        />\n      )}\n      \n      {/* Breadcrumbs */}\n      <Breadcrumbs \n        items={[{ label: 'Blog', href: '/blog' }]} \n        currentPage={post.title} \n      />\n      \n      {/* Main Blog Post Content */}\n      <BlogPost post={post} />\n\n      {/* \u2705 NEW - Related Posts Section */}\n      <section className=\"bg-gray-50 py-12\">\n        <div className=\"container mx-auto px-4\">\n          <RelatedPosts currentSlug={slug} />\n        </div>\n      </section>\n    </>\n  );\n}\n"
  },
  {
    "path": "src/components/Blog/BlogPost.tsx",
    "content": "import Image from 'next/image';\nimport Link from 'next/link';\nimport { BlogPost as BlogPostType } from '@/types/blog';\nimport BlogSidebar from './BlogSidebar';\nimport CommentSection from '@/components/Blog/CommentSection';\nimport TLDRSection from './TLDRSection'; // \u2728 NEW IMPORT\n\ninterface BlogPostProps {\n  post: BlogPostType;\n}\n\nexport default function BlogPost({ post }: BlogPostProps) {\n  // Extract headings for Table of Contents\n  const tableOfContents = extractHeadings(post.content);\n  \n  // Related posts\n  const relatedPosts = [\n    {\n      slug: 'halloween-nail-ideas-2025',\n      title: '35+ Halloween Nail Ideas 2025',\n      image: '/images/blog/halloweenhero.png'\n    },\n    {\n      slug: 'christmas-nail-designs-2025',\n      title: '18 Christmas Nail Designs 2025',\n      image: '/images/blog/christmas-nail-designs-2025-hero.jpg'\n    }\n  ].filter(p => p.slug !== post.slug);\n\n  return (\n    <div className=\"max-w-7xl mx-auto px-4 py-8\">\n      <div className=\"mb-6\">\n        <Link \n          href=\"/blog\"\n          className=\"text-blue-600 hover:text-blue-800 inline-flex items-center gap-2\"\n        >\n          \u2190 Back to Blog\n        </Link>\n      </div>\n\n      {/* Hero Section */}\n      <div className=\"max-w-4xl mx-auto mb-12 text-center\">\n        <h1 className=\"text-4xl md:text-5xl font-bold text-gray-900 mb-4\">\n          {post.title}\n        </h1>\n        \n        <div className=\"flex items-center justify-center gap-4 text-sm text-gray-600 mb-6\">\n          <span>By {post.author}</span>\n          <span>\u2022</span>\n          <span>{new Date(post.date).toLocaleDateString()}</span>\n          <span>\u2022</span>\n          <span>{post.readTime} read</span>\n        </div>\n\n        <div className=\"flex flex-wrap justify-center gap-2 mb-8\">\n          {/* \u2705 Show category badge first if exists */}\n          {post.category && (\n            <span className=\"bg-purple-100 text-purple-700 px-3 py-1 rounded-full text-sm font-semibold\">\n              {post.category}\n            </span>\n          )}\n          \n          {post.tags.map(tag => (\n            <span \n              key={tag}\n              className=\"bg-pink-100 text-pink-700 px-3 py-1 rounded-full text-sm font-medium\"\n            >\n              {tag}\n            </span>\n          ))}\n        </div>\n        \n        {post.image && (\n          <div className=\"relative h-96 w-full rounded-2xl overflow-hidden shadow-2xl\">\n            <Image\n              src={post.image}\n              alt={post.title}\n              fill\n              className=\"object-cover\"\n              priority\n            />\n          </div>\n        )}\n      </div>\n\n      {/* \u2728 TL;DR SECTION - CRITICAL: Place AFTER header, BEFORE content */}\n      {post.tldr && (\n        <div className=\"max-w-4xl mx-auto mb-12\">\n          <TLDRSection \n            summary={post.tldr.summary}\n            readTime={String(post.readTime)}  // \u2705 Ensure it's a string\n            keyTakeaways={post.tldr.keyTakeaways}\n          />\n        </div>\n      )}\n\n      {/* Two Column Layout */}\n      <div className=\"grid grid-cols-1 lg:grid-cols-12 gap-8\">\n        {/* Main Content - Takes 8 columns on large screens */}\n        <article className=\"lg:col-span-8\">\n          <div \n            className=\"prose prose-lg max-w-none \n            [&_h2]:text-pink-600 [&_h2]:text-3xl [&_h2]:mt-12 [&_h2]:mb-6 [&_h2]:font-bold [&_h2]:scroll-mt-24\n            [&_h3]:text-purple-600 [&_h3]:text-xl [&_h3]:mt-8 [&_h3]:mb-4 [&_h3]:font-semibold\n            [&_p]:text-gray-700 [&_p]:leading-relaxed [&_p]:mb-4\n            [&_ul]:my-4 [&_li]:mb-2\n            [&_strong]:text-gray-900 [&_strong]:font-semibold\n            [&_a]:text-blue-600 [&_a]:no-underline hover:[&_a]:text-blue-800\n            [&_img]:rounded-lg [&_img]:shadow-lg [&_img]:my-8\n            [&_hr]:my-8 [&_hr]:border-pink-200\"\n            dangerouslySetInnerHTML={{ __html: post.content }}\n          />\n\n          {/* Comment Section */}\n          <CommentSection postSlug={post.slug} postTitle={post.title} />\n        </article>\n\n        {/* Sidebar - Takes 4 columns on large screens */}\n        <aside className=\"lg:col-span-4\">\n          <BlogSidebar\n            tableOfContents={tableOfContents}\n            relatedPosts={relatedPosts}\n          />\n        </aside>\n      </div>\n    </div>\n  );\n}\n\n// Extract and clean heading text\nfunction extractHeadings(htmlContent: string): { id: string; title: string }[] {\n  const headings: { id: string; title: string }[] = [];\n  const regex = /<h2[^>]*id=\"([^\"]*)\"[^>]*>(.*?)<\\/h2>/gi;\n  let match;\n  \n  while ((match = regex.exec(htmlContent)) !== null) {\n    const id = match[1];\n    const rawTitle = match[2];\n    // Strip ALL HTML tags and decode entities\n    const title = rawTitle\n      .replace(/<[^>]*>/g, '')\n      .replace(/&amp;/g, '&')\n      .replace(/&lt;/g, '<')\n      .replace(/&gt;/g, '>')\n      .replace(/&quot;/g, '\"')\n      .trim();\n    \n    headings.push({ id, title });\n  }\n  \n  return headings;\n}\n"
  },
  {
    "path": "src/lib/blog.ts",
    "content": "// import fs from 'fs';\n// import path from 'path';\n// import matter from 'gray-matter';\n// import { BlogPost, BlogMetadata } from '@/types/blog';\n// import { marked } from 'marked';\n\n// marked.setOptions({\n//   breaks: true,\n//   gfm: true,\n// });\n\n// // src/lib/blog.ts\n\n// const METADATA_DIRECTORY = path.join(process.cwd(), 'src/content/metadata');\n\n// // Cache for metadata files\n// const metadataCache: { [key: string]: any } = {};\n\n// function loadMetadataFile(filename: string): any {\n//   if (metadataCache[filename]) return metadataCache[filename];\n  \n//   try {\n//     const filePath = path.join(METADATA_DIRECTORY, filename);\n//     if (fs.existsSync(filePath)) {\n//       const content = fs.readFileSync(filePath, 'utf8');\n//       metadataCache[filename] = JSON.parse(content);\n//       return metadataCache[filename];\n//     }\n//   } catch (error) {\n//     console.error(`Error loading ${filename}:`, error);\n//   }\n  \n//   return {};\n// }\n\n// // \u2705 NEW: Get metadata for a specific slug\n// function getMetadataFromJSON(slug: string): BlogMetadata | null {\n//   try {\n//     const titles = loadMetadataFile('titles.json');\n//     const excerpts = loadMetadataFile('excerpts.json');\n//     const tags = loadMetadataFile('tags.json');\n//     const images = loadMetadataFile('images.json');\n//     const imageAlts = loadMetadataFile('imageAlts.json');\n//     const dateModified = loadMetadataFile('dateModified.json');\n//     const tldr = loadMetadataFile('tldr.json');\n//     const faqItems = loadMetadataFile('faqItems.json');\n\n//     return {\n//       slug,\n//       title: titles[slug] || 'Untitled',\n//       excerpt: excerpts[slug] || '',\n//       tags: tags[slug] || [],\n//       image: images[slug] || null,\n//       imageAlt: imageAlts[slug] || null,\n//       dateModified: dateModified[slug] || null,\n//       tldr: tldr[slug] || null,\n//       faqItems: faqItems[slug] || null,\n//     };\n//   } catch (error) {\n//     console.error(`Error reading metadata for ${slug}:`, error);\n//     return null;\n//   }\n// }\n// // \u2705 Fallback to frontmatter\n// function getMetadataFromFrontmatter(slug: string): BlogMetadata | null {\n//   try {\n//     const filePath = path.join(BLOG_DIRECTORY, `${slug}.md`);\n//     const content = fs.readFileSync(filePath, 'utf8');\n//     const { data } = matter(content);\n\n//     return {\n//       slug,\n//       title: data.title || 'Untitled',\n//       excerpt: data.excerpt || '',\n//       date: data.date || new Date().toISOString(),\n//       author: data.author || 'Anonymous',\n//       tags: data.tags || [],\n//       image: data.image || null,\n//       readTime: data.readTime || '5 min',\n//       imageAlt: data.imageAlt || undefined,\n//       category: data.category || undefined,\n//     };\n//   } catch (error) {\n//     console.error(`Error reading frontmatter for ${slug}:`, error);\n//     return null;\n//   }\n// }\n\n// // \u2705 Get all blog posts\n// export async function getAllBlogPosts(): Promise<BlogMetadata[]> {\n//   try {\n//     const files = fs.readdirSync(BLOG_DIRECTORY);\n//     const posts = files\n//       .filter((file) => file.endsWith('.md'))\n//       .map((file) => {\n//         const slug = file.replace('.md', '');\n//         const metadata = getMetadataFromJSON(slug) || getMetadataFromFrontmatter(slug);\n//         if (!metadata) return null;\n//         return { ...metadata, slug };\n//       })\n//       .filter((post): post is BlogMetadata => post !== null)\n//       .sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());\n\n//     return posts;\n//   } catch (error) {\n//     console.error('Error reading blog posts:', error);\n//     return [];\n//   }\n// }\n\n// // \u2705 Get single blog post\n// export async function getBlogPost(slug: string): Promise<BlogPost | null> {\n//   try {\n//     const filePath = path.join(BLOG_DIRECTORY, `${slug}.md`);\n//     const fileContent = fs.readFileSync(filePath, 'utf8');\n//     const { data, content: markdownContent } = matter(fileContent);\n//     const metadata = getMetadataFromJSON(slug);\n\n//     let htmlContent = await marked(markdownContent);\n//     htmlContent = htmlContent.replace(/<h2>(.*?)<\\/h2>/g, (match, text) => {\n//       const cleanText = text.replace(/<[^>]*>/g, '');\n//       const id = cleanText\n//         .toLowerCase()\n//         .replace(/[^a-z0-9]+/g, '-')\n//         .replace(/^-+|-+$/g, '');\n//       return `<h2 id=\"${id}\">${text}</h2>`;\n//     });\n\n//     const tldr = data.tldr\n//       ? {\n//           summary: data.tldr.summary || [],\n//           keyTakeaways: data.tldr.keyTakeaways || [],\n//         }\n//       : undefined;\n\n//     return {\n//       slug,\n//       title: metadata?.title || data.title || 'Untitled',\n//       excerpt: metadata?.excerpt || data.excerpt || '',\n//       content: htmlContent,\n//       date: metadata?.date || data.date || new Date().toISOString(),\n//       author: metadata?.author || data.author || 'Anonymous',\n//       tags: metadata?.tags || data.tags || [],\n//       image: metadata?.image || data.image || null,\n//       readTime: metadata?.readTime || data.readTime || '5 min',\n//       canonical: metadata?.canonical || data.canonical || `https://mirelleinspo.com/blog/${slug}`,\n//       updatedDate: metadata?.updatedDate || data.updatedDate || undefined,\n//       category: metadata?.category || data.category || undefined,\n//       imageAlt: metadata?.imageAlt || data.imageAlt || undefined,\n//       imageWidth: metadata?.imageWidth || data.imageWidth || undefined,\n//       imageHeight: metadata?.imageHeight || data.imageHeight || undefined,\n//       dateModified: metadata?.dateModified || data.dateModified || data.updatedDate || undefined,\n//       wordCount: metadata?.wordCount || data.wordCount || undefined,\n//       faqItems: data.faqItems || undefined,\n//       tutorialSteps: data.tutorialSteps || undefined,\n//       tutorialMetadata: data.tutorialMetadata || undefined,\n//       videoMetadata: data.videoMetadata || undefined,\n//       galleryImages: metadata?.galleryImages || data.galleryImages || undefined,\n//       tldr,\n//     };\n//   } catch (error) {\n//     console.error(`Error reading blog post ${slug}:`, error);\n//     return null;\n//   }\n// }\n\n// // \u2705 Get all slugs\n// export async function getAllBlogSlugs(): Promise<string[]> {\n//   try {\n//     const files = fs.readdirSync(BLOG_DIRECTORY);\n//     return files.filter((file) => file.endsWith('.md')).map((file) => file.replace('.md', ''));\n//   } catch (error) {\n//     console.error('Error reading blog slugs:', error);\n//     return [];\n//   }\n// }\n\n// // \u2705 Get posts by category\n// export async function getPostsByCategory(categorySlug: string): Promise<BlogMetadata[]> {\n//   const allPosts = await getAllBlogPosts();\n//   return allPosts.filter((post) => {\n//     if (!post.category) return false;\n//     const postCategorySlug = post.category.toLowerCase().replace(/[^a-z0-9]+/g, '-');\n//     return postCategorySlug === categorySlug;\n//   });\n// }\n\n// // \u2705 Get posts by tag\n// export async function getPostsByTag(tagSlug: string): Promise<BlogMetadata[]> {\n//   const allPosts = await getAllBlogPosts();\n//   return allPosts.filter((post) =>\n//     post.tags.some((tag) => {\n//       const tagSlugified = tag.toLowerCase().replace(/[^a-z0-9]+/g, '-');\n//       return tagSlugified === tagSlug;\n//     })\n//   );\n// }\n\n// // \u2705 Get all categories with slug + count\n// export async function getAllCategories(): Promise<{ name: string; slug: string; count: number; description: string }[]> {\n//   const allPosts = await getAllBlogPosts();\n//   const categoryMap = new Map<string, number>();\n\n//   allPosts.forEach((post) => {\n//     if (post.category) {\n//       categoryMap.set(post.category, (categoryMap.get(post.category) || 0) + 1);\n//     }\n//   });\n\n//   return Array.from(categoryMap.entries())\n//     .map(([name, count]) => ({\n//       name,\n//       slug: name.toLowerCase().replace(/[^a-z0-9]+/g, '-'),\n//       count,\n//       description: `Expert articles about ${name}`,\n//     }))\n//     .sort((a, b) => b.count - a.count);\n// }\n\n// // \u2705 Get all tags with slug + count\n// export async function getAllTags(): Promise<{ name: string; slug: string; count: number }[]> {\n//   const allPosts = await getAllBlogPosts();\n//   const tagMap = new Map<string, number>();\n\n//   allPosts.forEach((post) => {\n//     post.tags.forEach((tag) => {\n//       tagMap.set(tag, (tagMap.get(tag) || 0) + 1);\n//     });\n//   });\n\n//   return Array.from(tagMap.entries())\n//     .map(([name, count]) => ({\n//       name,\n//       slug: name.toLowerCase().replace(/[^a-z0-9]+/g, '-'),\n//       count,\n//     }))\n//     .sort((a, b) => b.count - a.count);\n// }\n\n// // \u2705 Related posts\n// export async function getRelatedPosts(slug: string, limit: number = 3): Promise<BlogMetadata[]> {\n//   const currentPost = await getBlogPost(slug);\n//   if (!currentPost) return [];\n\n//   const allPosts = await getAllBlogPosts();\n\n//   const scoredPosts = allPosts\n//     .filter((post) => post.slug !== slug)\n//     .map((post) => {\n//       let score = 0;\n//       if (post.category && post.category === currentPost.category) score += 10;\n//       const matchingTags = post.tags.filter((tag) => currentPost.tags.includes(tag));\n//       score += matchingTags.length * 5;\n//       return { post, score };\n//     })\n//     .filter((item) => item.score > 0)\n//     .sort((a, b) => b.score - a.score)\n//     .slice(0, limit);\n\n//   return scoredPosts.map((item) => item.post);\n// }\n\n// // \u2705 Paginated posts\n// export async function getPaginatedPosts(\n//   page: number = 1,\n//   perPage: number = 12\n// ): Promise<{\n//   posts: BlogMetadata[];\n//   totalPages: number;\n//   currentPage: number;\n//   totalPosts: number;\n// }> {\n//   const allPosts = await getAllBlogPosts();\n//   const totalPosts = allPosts.length;\n//   const totalPages = Math.ceil(totalPosts / perPage);\n//   const start = (page - 1) * perPage;\n//   const end = start + perPage;\n//   const posts = allPosts.slice(start, end);\n\n//   return { posts, totalPages, currentPage: page, totalPosts };\n// }\n\n// // \u2705 Search\n// export async function searchPosts(query: string): Promise<BlogMetadata[]> {\n//   if (!query.trim()) return [];\n\n//   const allPosts = await getAllBlogPosts();\n//   const lowerQuery = query.toLowerCase();\n\n//   return allPosts.filter((post) => {\n//     const searchText = `${post.title} ${post.excerpt} ${post.tags.join(' ')} ${post.category || ''}`.toLowerCase();\n//     return searchText.includes(lowerQuery);\n//   });\n// }\n\n// src/lib/blog.ts\n\nimport fs from 'fs';\nimport path from 'path';\nimport matter from 'gray-matter';\nimport { BlogPost, BlogMetadata } from '@/types/blog';\nimport { marked } from 'marked';\n\nmarked.setOptions({\n  breaks: true,\n  gfm: true,\n});\n\nconst BLOG_DIRECTORY = path.join(process.cwd(), 'src/content/blogs');\nconst METADATA_DIRECTORY = path.join(process.cwd(), 'src/content/metadata');\n\n// Cache for metadata files\nconst metadataCache: { [key: string]: any } = {};\n\nfunction loadMetadataFile(filename: string): any {\n  if (metadataCache[filename]) return metadataCache[filename];\n  \n  try {\n    const filePath = path.join(METADATA_DIRECTORY, filename);\n    if (fs.existsSync(filePath)) {\n      const content = fs.readFileSync(filePath, 'utf8');\n      metadataCache[filename] = JSON.parse(content);\n      return metadataCache[filename];\n    }\n  } catch (error) {\n    console.error(`Error loading ${filename}:`, error);\n  }\n  \n  return {};\n}\n\n// \u2705 Get metadata from JSON files (only editable fields)\nfunction getMetadataFromJSON(slug: string): Partial<BlogMetadata> | null {\n  try {\n    const titles = loadMetadataFile('titles.json');\n    const excerpts = loadMetadataFile('excerpts.json');\n    const tags = loadMetadataFile('tags.json');\n    const images = loadMetadataFile('images.json');\n    const imageAlts = loadMetadataFile('imageAlts.json');\n    const dateModified = loadMetadataFile('dateModified.json');\n    const tldr = loadMetadataFile('tldr.json');\n    const faqItems = loadMetadataFile('faqItems.json');\n\n    return {\n      title: titles[slug],\n      excerpt: excerpts[slug],\n      tags: tags[slug],\n      image: images[slug],\n      imageAlt: imageAlts[slug],\n      dateModified: dateModified[slug],\n      tldr: tldr[slug],\n      faqItems: faqItems[slug],\n    };\n  } catch (error) {\n    console.error(`Error reading metadata for ${slug}:`, error);\n    return null;\n  }\n}\n\n// \u2705 Get metadata from MD frontmatter (core fields)\nfunction getMetadataFromFrontmatter(slug: string): Partial<BlogMetadata> | null {\n  try {\n    const filePath = path.join(BLOG_DIRECTORY, `${slug}.md`);\n    const content = fs.readFileSync(filePath, 'utf8');\n    const { data } = matter(content);\n\n    return {\n      date: data.date,\n      author: data.author,\n      readTime: data.readTime,\n      category: data.category,\n      // Add any other core fields that should come from MD\n    };\n  } catch (error) {\n    console.error(`Error reading frontmatter for ${slug}:`, error);\n    return null;\n  }\n}\n\n// \u2705 Get all blog posts (combine JSON + MD data)\nexport async function getAllBlogPosts(): Promise<BlogMetadata[]> {\n  try {\n    const files = fs.readdirSync(BLOG_DIRECTORY);\n    const posts = files\n      .filter((file) => file.endsWith('.md'))\n      .map((file) => {\n        const slug = file.replace('.md', '');\n        const jsonMetadata = getMetadataFromJSON(slug) || {};\n        const mdMetadata = getMetadataFromFrontmatter(slug) || {};\n\n        // \u2705 Merge: JSON overrides for editable fields, MD for core fields\n        return {\n          slug,\n          title: jsonMetadata.title || 'Untitled',\n          excerpt: jsonMetadata.excerpt || '',\n          date: mdMetadata.date || new Date().toISOString(),\n          author: mdMetadata.author || 'Anonymous',\n          readTime: mdMetadata.readTime || '5 min',\n          tags: jsonMetadata.tags || [],\n          image: jsonMetadata.image || null,\n          imageAlt: jsonMetadata.imageAlt,\n          category: mdMetadata.category,\n          dateModified: jsonMetadata.dateModified,\n          tldr: jsonMetadata.tldr,\n          faqItems: jsonMetadata.faqItems,\n        } as BlogMetadata;\n      })\n      .filter((post): post is BlogMetadata => post !== null)\n      .sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());\n\n    return posts;\n  } catch (error) {\n    console.error('Error reading blog posts:', error);\n    return [];\n  }\n}\n\n// \u2705 Get single blog post (combine JSON + MD data + content)\nexport async function getBlogPost(slug: string): Promise<BlogPost | null> {\n  try {\n    const filePath = path.join(BLOG_DIRECTORY, `${slug}.md`);\n    const fileContent = fs.readFileSync(filePath, 'utf8');\n    const { data, content: markdownContent } = matter(fileContent);\n    \n    const jsonMetadata = getMetadataFromJSON(slug) || {};\n\n    let htmlContent = await marked(markdownContent);\n    htmlContent = htmlContent.replace(/<h2>(.*?)<\\/h2>/g, (match, text) => {\n      const cleanText = text.replace(/<[^>]*>/g, '');\n      const id = cleanText\n        .toLowerCase()\n        .replace(/[^a-z0-9]+/g, '-')\n        .replace(/^-+|-+$/g, '');\n      return `<h2 id=\"${id}\">${text}</h2>`;\n    });\n\n    return {\n      slug,\n      // \u2705 From JSON metadata (editable)\n      title: jsonMetadata.title || data.title || 'Untitled',\n      excerpt: jsonMetadata.excerpt || data.excerpt || '',\n      tags: jsonMetadata.tags || data.tags || [],\n      image: jsonMetadata.image || data.image || null,\n      imageAlt: jsonMetadata.imageAlt || data.imageAlt,\n      dateModified: jsonMetadata.dateModified || data.dateModified,\n      tldr: jsonMetadata.tldr || data.tldr,\n      faqItems: jsonMetadata.faqItems || data.faqItems,\n      \n      // \u2705 From MD frontmatter (core content)\n      content: htmlContent,\n      date: data.date || new Date().toISOString(),\n      author: data.author || 'Anonymous',\n      readTime: data.readTime || '5 min',\n      category: data.category,\n      canonical: `https://mirelleinspo.com/blog/${slug}`,\n      \n      // \u2705 Optional fields from MD\n      updatedDate: data.updatedDate,\n      imageWidth: data.imageWidth,\n      imageHeight: data.imageHeight,\n      wordCount: data.wordCount,\n      tutorialSteps: data.tutorialSteps,\n      tutorialMetadata: data.tutorialMetadata,\n      videoMetadata: data.videoMetadata,\n      galleryImages: data.galleryImages,\n    };\n  } catch (error) {\n    console.error(`Error reading blog post ${slug}:`, error);\n    return null;\n  }\n}\n\n// \u2705 Keep all other functions the same...\nexport async function getAllBlogSlugs(): Promise<string[]> {\n  try {\n    const files = fs.readdirSync(BLOG_DIRECTORY);\n    return files.filter((file) => file.endsWith('.md')).map((file) => file.replace('.md', ''));\n  } catch (error) {\n    console.error('Error reading blog slugs:', error);\n    return [];\n  }\n}\n\nexport async function getPostsByCategory(categorySlug: string): Promise<BlogMetadata[]> {\n  const allPosts = await getAllBlogPosts();\n  return allPosts.filter((post) => {\n    if (!post.category) return false;\n    const postCategorySlug = post.category.toLowerCase().replace(/[^a-z0-9]+/g, '-');\n    return postCategorySlug === categorySlug;\n  });\n}\n\nexport async function getPostsByTag(tagSlug: string): Promise<BlogMetadata[]> {\n  const allPosts = await getAllBlogPosts();\n  return allPosts.filter((post) =>\n    post.tags.some((tag) => {\n      const tagSlugified = tag.toLowerCase().replace(/[^a-z0-9]+/g, '-');\n      return tagSlugified === tagSlug;\n    })\n  );\n}\n\nexport async function getAllCategories(): Promise<{ name: string; slug: string; count: number; description: string }[]> {\n  const allPosts = await getAllBlogPosts();\n  const categoryMap = new Map<string, number>();\n\n  allPosts.forEach((post) => {\n    if (post.category) {\n      categoryMap.set(post.category, (categoryMap.get(post.category) || 0) + 1);\n    }\n  });\n\n  return Array.from(categoryMap.entries())\n    .map(([name, count]) => ({\n      name,\n      slug: name.toLowerCase().replace(/[^a-z0-9]+/g, '-'),\n      count,\n      description: `Expert articles about ${name}`,\n    }))\n    .sort((a, b) => b.count - a.count);\n}\n\nexport async function getAllTags(): Promise<{ name: string; slug: string; count: number }[]> {\n  const allPosts = await getAllBlogPosts();\n  const tagMap = new Map<string, number>();\n\n  allPosts.forEach((post) => {\n    post.tags.forEach((tag) => {\n      tagMap.set(tag, (tagMap.get(tag) || 0) + 1);\n    });\n  });\n\n  return Array.from(tagMap.entries())\n    .map(([name, count]) => ({\n      name,\n      slug: name.toLowerCase().replace(/[^a-z0-9]+/g, '-'),\n      count,\n    }))\n    .sort((a, b) => b.count - a.count);\n}\n\nexport async function getRelatedPosts(slug: string, limit: number = 3): Promise<BlogMetadata[]> {\n  const currentPost = await getBlogPost(slug);\n  if (!currentPost) return [];\n\n  const allPosts = await getAllBlogPosts();\n\n  const scoredPosts = allPosts\n    .filter((post) => post.slug !== slug)\n    .map((post) => {\n      let score = 0;\n      if (post.category && post.category === currentPost.category) score += 10;\n      const matchingTags = post.tags.filter((tag) => currentPost.tags.includes(tag));\n      score += matchingTags.length * 5;\n      return { post, score };\n    })\n    .filter((item) => item.score > 0)\n    .sort((a, b) => b.score - a.score)\n    .slice(0, limit);\n\n  return scoredPosts.map((item) => item.post);\n}\n\nexport async function getPaginatedPosts(\n  page: number = 1,\n  perPage: number = 12\n): Promise<{\n  posts: BlogMetadata[];\n  totalPages: number;\n  currentPage: number;\n  totalPosts: number;\n}> {\n  const allPosts = await getAllBlogPosts();\n  const totalPosts = allPosts.length;\n  const totalPages = Math.ceil(totalPosts / perPage);\n  const start = (page - 1) * perPage;\n  const end = start + perPage;\n  const posts = allPosts.slice(start, end);\n\n  return { posts, totalPages, currentPage: page, totalPosts };\n}\n\nexport async function searchPosts(query: string): Promise<BlogMetadata[]> {\n  if (!query.trim()) return [];\n\n  const allPosts = await getAllBlogPosts();\n  const lowerQuery = query.toLowerCase();\n\n  return allPosts.filter((post) => {\n    const searchText = `${post.title} ${post.excerpt} ${post.tags.join(' ')} ${post.category || ''}`.toLowerCase();\n    return searchText.includes(lowerQuery);\n  });\n}\n"
  }
]
